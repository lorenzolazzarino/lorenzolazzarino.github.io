#!/usr/bin/env bash
# upcoming - CLI to manage upcoming.html entries
# Usage:
#   ./upcoming add "12 Sept. 2026" "Seminar at Oxford"
#   ./upcoming list
#   ./upcoming remove 2
#   ./upcoming edit 3
set -euo pipefail

# Config
FILE="upcoming.html"
BACKUP_SUFFIX=".bak.$(date +%Y%m%d%H%M%S)"
GIT_OPTS=( --no-git ) # default overwritten per-command

# parse top-level args
cmd="${1:-}"
shift || true

# helper: run python block with args forwarded
run_python() {
  python3 - "$FILE" "$@" <<'PYCODE'
import sys, os, re, html
from datetime import datetime

FPATH = sys.argv[1]
cmd = sys.argv[2] if len(sys.argv) > 2 else ""
args = sys.argv[3:]

# Helpers
def read_file():
    with open(FPATH, "r", encoding="utf-8") as f:
        return f.read()

def write_file(text):
    with open(FPATH, "w", encoding="utf-8") as f:
        f.write(text)

def extract_main(html_text):
    m = re.search(r'(<main[^>]*id=["\']?upcomingContent["\']?[^>]*>)(.*?)(</main>)',
                  html_text, flags=re.DOTALL|re.IGNORECASE)
    if not m:
        # fallback: try to find <main>..</main>
        m = re.search(r'(<main[^>]*>)(.*?)(</main>)',
                      html_text, flags=re.DOTALL|re.IGNORECASE)
        if not m:
            raise SystemExit("Error: can't find <main id=\"upcomingContent\"> ... </main> in "+FPATH)
    return m.group(1), m.group(2), m.group(3)

def split_entries(main_inner):
    # find all <div class="upcoming-entry"> ... </div> non-greedy
    pattern = re.compile(r'(<div[^>]*class=["\']?upcoming-entry["\']?[^>]*>.*?</div>)',
                         flags=re.DOTALL|re.IGNORECASE)
    items = pattern.findall(main_inner)
    return items

def parse_date_from_entry(entry_html):
    m = re.search(r'<div[^>]*class=["\']?upcoming-date["\']?[^>]*>(.*?)</div>',
                  entry_html, flags=re.DOTALL|re.IGNORECASE)
    if not m:
        return None
    txt = re.sub(r'<.*?>','',m.group(1)).strip()
    txt = txt.replace('\xa0',' ').strip()
    # try several patterns
    def try_parse(s):
        s = s.replace('.','').strip()  # remove dots after month abbreviations
        # patterns: "12 Sept 2025", "Sept 12, 2025", "2025-09-12", "12/09/2025"
        months = {'jan':1,'january':1,'feb':2,'february':2,'mar':3,'march':3,'apr':4,'april':4,'may':5,
                  'jun':6,'june':6,'jul':7,'july':7,'aug':8,'august':8,'sep':9,'sept':9,'september':9,
                  'oct':10,'october':10,'nov':11,'november':11,'dec':12,'december':12}
        # ISO
        try:
            return datetime.fromisoformat(s).date()
        except Exception:
            pass
        # try dd Month yyyy
        m1 = re.match(r'^(\\d{1,2})\\s+([A-Za-z]+)\\s+(\\d{4})$', s)
        if m1:
            d=int(m1.group(1)); mo=months.get(m1.group(2).lower())
            if mo: return datetime(int(m1.group(3)), mo, d).date()
        # Month dd, yyyy
        m2 = re.match(r'^([A-Za-z]+)\\s+(\\d{1,2}),?\\s*(\\d{4})$', s)
        if m2:
            mo=months.get(m2.group(1).lower()); d=int(m2.group(2))
            if mo: return datetime(int(m2.group(3)), mo, d).date()
        # dd-mm-yyyy or dd/mm/yyyy
        m3 = re.match(r'^(\\d{1,2})[\\/-](\\d{1,2})[\\/-](\\d{2,4})$', s)
        if m3:
            d=int(m3.group(1)); m=int(m3.group(2)); y=int(m3.group(3))
            if y < 100: y += 2000
            return datetime(y,m,d).date()
        # fallback: try datetime parser
        try:
            import dateutil.parser as dp
            return dp.parse(s).date()
        except Exception:
            return None
    return try_parse(txt)

def strip_tags(s):
    return re.sub(r'<[^>]+>', '', s).strip()

# Commands
if cmd == "list":
    text = read_file()
    head, inner, tail = extract_main(text)
    entries = split_entries(inner)
    if not entries:
        print("No upcoming entries.")
        sys.exit(0)
    parsed = []
    for i,e in enumerate(entries,1):
        # parse date
        date = parse_date_from_entry(e)
        date_str = date.isoformat() if date else "----"
    
        # extract only upcoming-text
        mtext = re.search(
            r'<div[^>]*class=["\']?upcoming-text["\']?[^>]*>(.*?)</div>',
            e,
            flags=re.DOTALL | re.IGNORECASE
        )
    
        short = strip_tags(mtext.group(1)).strip() if mtext else "(no description)"
        parsed.append((i, date_str, short))

    for i,d,s in parsed:
        print(f"{i:>3}. {d:10}  {s}")
    sys.exit(0)

elif cmd == "add":
    if len(args) < 2:
        print("Usage: upcoming add \"DATE\" \"TEXT\"")
        sys.exit(1)
    date = args[0]
    textpart = args[1]
    filetext = read_file()
    head, inner, tail = extract_main(filetext)
    # build entry
    entry = '\\n  <div class=\"upcoming-entry\">\\n    <div class=\"upcoming-date\">' + html.escape(date) + '</div>\\n    <div class=\"upcoming-text\">' + textpart + '</div>\\n  </div>\\n'
    new_inner = inner + entry
    newfile = head + new_inner + tail
    # backup
    import shutil
    shutil.copy(FPATH, FPATH + ".bak")
    write_file(newfile)
    print(f"Added event: {date} â€” {strip_tags(textpart)}")
    sys.exit(0)

elif cmd == "remove":
    if len(args) < 1:
        print("Usage: upcoming remove INDEX")
        sys.exit(1)
    idx = int(args[0])
    text = read_file()
    head, inner, tail = extract_main(text)
    entries = split_entries(inner)
    if idx < 1 or idx > len(entries):
        print("Index out of range.")
        sys.exit(1)
    removed = entries.pop(idx-1)
    new_inner = "\\n".join(entries) + ("\\n" if entries else "\\n")
    # backup
    import shutil
    shutil.copy(FPATH, FPATH + ".bak")
    write_file(head + new_inner + tail)
    print("Removed entry #{}: {}".format(idx, strip_tags(removed)))
    sys.exit(0)

elif cmd == "edit":
    if len(args) < 1:
        print("Usage: upcoming edit INDEX")
        sys.exit(1)
    idx = int(args[0])
    text = read_file()
    head, inner, tail = extract_main(text)
    entries = split_entries(inner)
    if idx < 1 or idx > len(entries):
        print("Index out of range.")
        sys.exit(1)
    target = entries[idx-1]
    # extract date and text
    mdate = re.search(r'<div[^>]*class=["\']?upcoming-date["\']?[^>]*>(.*?)</div>', target, flags=re.DOTALL|re.IGNORECASE)
    mtext = re.search(r'<div[^>]*class=["\']?upcoming-text["\']?[^>]*>(.*?)</div>', target, flags=re.DOTALL|re.IGNORECASE)
    curdate = strip_tags(mdate.group(1)) if mdate else ""
    curtext = (mtext.group(1) if mtext else "").strip()
    # create temp file for $EDITOR
    import tempfile, subprocess
    tf = tempfile.NamedTemporaryFile(delete=False, suffix=".txt", mode="w", encoding="utf-8")
    tf.write(f"# Edit the event below. First line is the DATE. The rest is the HTML/text for the right column.\\n")
    tf.write(f"# Lines beginning with # are ignored. Save and close to apply.\\n\\n")
    tf.write(curdate + "\\n")
    tf.write(curtext + "\\n")
    tf.close()
    editor = os.environ.get("EDITOR", "nano")
    subprocess.call([editor, tf.name])
    # read back
    with open(tf.name,"r",encoding="utf-8") as f:
        lines = [ln.rstrip("\\n") for ln in f if not ln.lstrip().startswith("#")]
    if not lines:
        print("No changes made.")
        os.unlink(tf.name)
        sys.exit(0)
    new_date = lines[0].strip()
    new_text = "\\n".join(lines[1:]).strip()
    # build new entry
    new_entry = '<div class=\"upcoming-entry\">\\n    <div class=\"upcoming-date\">' + html.escape(new_date) + '</div>\\n    <div class=\"upcoming-text\">' + (new_text if new_text else "") + '</div>\\n  </div>'
    entries[idx-1] = new_entry
    new_inner = "\\n".join(entries) + ("\\n" if entries else "\\n")
    # backup
    import shutil
    shutil.copy(FPATH, FPATH + ".bak")
    write_file(head + new_inner + tail)
    os.unlink(tf.name)
    print(f"Edited entry #{idx}")
    sys.exit(0)

else:
    print("Unknown command. usage: upcoming [list|add|remove|edit]")
    sys.exit(1)
PYCODE
}

# Command handling and git integration
case "$cmd" in
  list)
    run_python list
    ;;
  add)
    # check flags for --no-git
    NO_GIT=0
    if [[ "${*: -1}" == "--no-git" ]]; then
      NO_GIT=1
      # remove trailing flag so python sees only two args
      set -- "${@:1:$(($#-1))}"
    fi
    run_python add "$@"
    if [ "${NO_GIT}" -eq 0 ]; then
      git add "$FILE"
      git commit -m "Add upcoming event: $1" || echo "No changes to commit."
      git push || echo "git push failed (check remote)."
    fi
    ;;
  remove)
    NO_GIT=0
    YES=0
    for arg in "$@"; do
      if [ "$arg" == "--no-git" ]; then NO_GIT=1; fi
      if [ "$arg" == "--yes" ]; then YES=1; fi
    done
    idx="${1:-}"
    if [ -z "$idx" ]; then
      echo "Usage: upcoming remove INDEX [--yes] [--no-git]"
      exit 1
    fi
    if [ "$YES" -ne 1 ]; then
      read -p "Remove entry #$idx? (y/N) " ans
      case "$ans" in [Yy]*) ;; *) echo "Aborted."; exit 1;; esac
    fi
    run_python remove "$idx"
    if [ "$NO_GIT" -eq 0 ]; then
      git add "$FILE"
      git commit -m "Remove upcoming event #$idx" || echo "No changes to commit."
      git push || echo "git push failed (check remote)."
    fi
    ;;
  edit)
    NO_GIT=0
    for arg in "$@"; do
      if [ "$arg" == "--no-git" ]; then NO_GIT=1; fi
    done
    idx="${1:-}"
    if [ -z "$idx" ]; then
      echo "Usage: upcoming edit INDEX [--no-git]"
      exit 1
    fi
    run_python edit "$idx"
    if [ "$NO_GIT" -eq 0 ]; then
      git add "$FILE"
      git commit -m "Edit upcoming event #$idx" || echo "No changes to commit."
      git push || echo "git push failed (check remote)."
    fi
    ;;
  *)
    cat <<USAGE
Usage: upcoming <command> [args]
Commands:
  list
    Show indexed upcoming entries.

  add "DATE" "TEXT" [--no-git]
    Add a new entry. TEXT can contain HTML. Default behaviour: git add/commit/push.
    Example:
      ./upcoming add "12 Sept. 2026" "Seminar at Oxford"

  remove INDEX [--yes] [--no-git]
    Remove entry by index (use 'list' to get indexes). --yes skips confirmation.

  edit INDEX [--no-git]
    Edit entry using \$EDITOR (first line = date, rest = HTML/text).

Notes:
  - The script expects an existing $FILE with a <main id="upcomingContent"> ... </main>.
  - Backups are created automatically (appended with .bak.TIMESTAMP) before modifying file.
USAGE
    ;;
esac
